#===============================================================================
# Title: ICER and Clinical Outcomes Calculation Script
#
# Description:
# This script processes simulation output data to calculate average clinical 
# and cost-effectiveness outcomes across multiple hepatitis C treatment strategies. 
# It generates two key outputs:
#   1. A finalized ICER (Incremental Cost-Effectiveness Ratio) table, accounting for 
#      both dominance and extended dominance.
#   2. A summary table of clinical outcomes (e.g., % identified, % SVR, % cirrhosis 
#      reduction, liver-related deaths).
#
# Inputs:
#   - 'organized_outputs.csv': A CSV file generated by `generate_outputs.py` from the 
#     `hepce_scripts` GitHub repository. This file contains per-strategy simulation 
#     outputs across multiple runs.
#
# Requirements:
#   - Manual specification of the `strategy_name` vector in the correct order matching 
#     the strategy numbering in the input data.
#
# Dependencies:
#   - tidyverse
#   - scales
#
# Outputs:
#   - final_icer: Table with life expectancy, QALYs, costs, and ICERs per strategy.
#   - final_clinical: Table summarizing clinical outcomes per strategy.
#
# Notes:
#   - ICER calculation accounts for dominance and extended dominance.
#   - Extended dominance is handled by iteratively checking and recalculating ICERs 
#     to ensure monotonicity.
#===============================================================================

# set wd dynamically for both RStudio and in command-line
if (requireNamespace("rstudioapi", quietly = TRUE) &&
    rstudioapi::isAvailable() &&
    !is.null(rstudioapi::getActiveDocumentContext()$path)) {
  setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
} else {
  args <- commandArgs(trailingOnly = FALSE)
  script_path <- sub("--file=", "", args[grep("--file=", args)])
  if (length(script_path)) {
    setwd(dirname(normalizePath(script_path)))
  } else {
    warning("Cannot determine script location. Working directory not changed.")
  }
}

library(tidyverse)
library(scales)

# this output should come from the organize_outputs.sh 
# script from the hepce_scripts bitbucket repository
outputs <- read.csv("organized_outputs.csv")


# **REQUIRES USER INPUT**
# list in the correct order to match strategy number
strategy_name <- c("No treatment (Comparator)",
                   "Treatment during pregnancy",
                   "Treatment at delivery",
                   "Linkage to HCV care post-partum")

strat_means <- outputs %>% select(-run.number) %>% 
  group_by(strategy) %>%
  summarize_all("mean")

# strategies in the name list must match the order of strat_means
strat_means <- cbind(strategy_name, strat_means)

#==================
# Create ICER Table
#==================

# all icer table values start with "Avg"
icer_vals <- strat_means %>% select(strategy, strategy_name,
                                    starts_with("Avg"))

# Sort by discounted cost; initialize is.dominated and icer columns
icer_vals <- icer_vals %>% 
  arrange(Avg.Discounted.Cost.per.person.in.USD) %>%
  mutate(is.dom = NA, icer = NA)

icer_vals$is.dom[1] <- FALSE

# Loop through the data to calculate icer and is.dom
for (i in 2:nrow(icer_vals)) {
  icer_value <- ((icer_vals$Avg.Discounted.Cost.per.person.in.USD[i] - icer_vals$Avg.Discounted.Cost.per.person.in.USD[1:(i-1)]) / 
                   (icer_vals$Avg.Discounted.QALY.per.person.multiplicative.method[i] - icer_vals$Avg.Discounted.QALY.per.person.multiplicative.method[1:(i-1)]))
  
  if (any(icer_value < 0)) {
    icer_vals$is.dom[i] <- TRUE
    icer_vals$icer[i] <- NA
  } else {
    
    # Initialize a flag to track whether a non-TRUE is.dom value has been found
    non_true_found <- FALSE
    
    # Check is.dom values within the range (i-1):1, starting from the last row and working backward
      for (j in (i-1):1) {
        if (!icer_vals$is.dom[j]) {
          icer_vals$is.dom[i] <- FALSE
          icer_vals$icer[i] <- icer_value[j] # Use the corresponding icer_value
          non_true_found <- TRUE
          break
        }
      }
      
      # If no non-TRUE value was found in is.dom, set icer to NA
      # this will never be true because row 2 will never be dominated and is set below
      if (!non_true_found) {
        icer_vals$icer[i] <- NA
      }
    } 
}

#==================
# Account for Extended Dominance:
# If the ICERs are not in increasing order, we need to account for extended dominance
# To do so, this portion of the code checks for extended dominance by continuous looping through the ICER column while it is NOT in ascending order
# With each repetition, the row index increases to the next non NA value, or until the reference
# Until the ICER table is in increasing order
#==================

# Create a logical vector to track NAs before the loop starts
# These mark strategies that were "Dominated" rather than "Extended Dominated"
is_na_before_loop <- is.na(icer_vals$icer)

# Set reference ICER to very low value
# The loop skips dominated/extended dominated strategies beacuse they are flagged NA
# So, we don't want to the reference to be skipped, but we always want it to be lowest value so (icer_value < icer_vals$icer[k]) is never TRUE in regard to the ref
# ICERs are recalculated based on cost/qalys, so introducing this number here does not change numbers
icer_vals$icer[1] <- -9999999

# Loop until all non-missing values in icer_vals$icer are in ascending order
for (i in 2:nrow(icer_vals)) {
  if (!is.na(icer_vals$icer[i])) {  # Check if icer[i] is not NA
    current_value <- icer_vals$icer[i]
    
    # Initialize the closest numeric value index as NULL
    closest_index <- NULL
    
    # Compare to rows above. If current value is < previous rows, set previous rows to NA -- those are extended dominated
    for (j in (i-1):1) {
      if (!is.na(icer_vals$icer[j]) && current_value < icer_vals$icer[j]) {
        icer_vals$icer[j] <- NA
        
        # Search for new index
        # This is why we do not want the reference icer to have NA value
        for (k in (i-1):1) {
          if (!is.na(icer_vals$icer[k])) {
            closest_index <- k
          }
        }
        
        # Recalculate icer_vals$icer[i] based on last non-NA value defined above in k
        if (!is.null(closest_index)) {
          icer_diff_cost <- icer_vals$Avg.Discounted.Cost.per.person.in.USD[i] - icer_vals$Avg.Discounted.Cost.per.person.in.USD[closest_index]
          icer_diff_qaly <- icer_vals$Avg.Discounted.QALY.per.person.multiplicative.method[i] - icer_vals$Avg.Discounted.QALY.per.person.multiplicative.method[closest_index]
          icer_value <- icer_diff_cost / icer_diff_qaly
          
          # Check if icer_value is less than icer_vals$icer[k]
          if (icer_value < icer_vals$icer[closest_index]) {
            icer_vals$icer[closest_index] <- NA
            icer_vals$icer[i] <- NA  # Set icer[i] to NA as well
          } else {
            # If new icer value is bigger than icer[k], set icer[i] to new value
            icer_vals$icer[i] <- icer_value
          }
        }
      }
    }
  }
}

# Replace NA values that were NA before the loop with "Dominated"
icer_vals$icer[is_na_before_loop] <- "Dominated"

# Replace any remaining NA values after the loop with "Extended Dominated"
icer_vals$icer[is.na(icer_vals$icer)] <- "Extended Dominated"

# Reset Row 1 to be reference
icer_vals$icer[1] <- "Reference"

icer_vals <- icer_vals %>% arrange(Avg.Discounted.Cost.per.person.in.USD)

final_icer <- icer_vals %>% ungroup() %>% select(`Strategy Number` = strategy,
                                                  `Strategy Name` = strategy_name,
                                                  `Remaining Life Expectancy` = Avg.Life.Span.per.person.in.Years,
                                                  `Undiscounted Cost ($)` = Avg.Cost.per.person.in.USD,
                                                  `Undiscounted QALY (mult)` = Avg.QALY.per.person.multiplicative.method,
                                                  `Discounted Cost ($)` = Avg.Discounted.Cost.per.person.in.USD,
                                                  `Discounted QALY (mult)` = Avg.Discounted.QALY.per.person.multiplicative.method,
                                                  `ICER (mult)` = icer
)

# Round and format non-NA values to currency
final_icer <- final_icer %>%
  mutate(
    `Remaining Life Expectancy` = ifelse(is.na(`Remaining Life Expectancy`), NA, round(`Remaining Life Expectancy`, 4)),
    `Undiscounted Cost ($)` = ifelse(is.na(`Undiscounted Cost ($)`), NA, paste0("$", format(round(`Undiscounted Cost ($)`, 0), big.mark = ","))),
    `Discounted Cost ($)` = ifelse(is.na(`Discounted Cost ($)`), NA, paste0("$", format(round(`Discounted Cost ($)`, 0), big.mark = ","))),
    `Discounted QALY (mult)` = ifelse(is.na(`Discounted QALY (mult)`), NA, round(`Discounted QALY (mult)`, 4)),
  )

#========================
# Clinical Outcomes Table
#========================

clinical_vals <- strat_means %>% select(strategy, strategy_name,
                                        starts_with("number"))

# reorder rows to match icer table

order_index <- match(final_icer$`Strategy Number`, clinical_vals$strategy)
final_icer <- final_icer %>% select(-`Strategy Number`)
clinical_vals_ord <- clinical_vals[order_index,]

# create percentages

clinical_calcs <- clinical_vals_ord %>% mutate(perc_ident_lifetime = number.of.total.HCV.identifications/number.of.total.HCV.infections,
                                               perc_svr = number.of.SVR.cases/number.of.total.HCV.identifications,
                                               perc_red_cirr = (lag(number.of.cirrhotic.people) - number.of.cirrhotic.people)/lag(number.of.cirrhotic.people),
                                               liver_deaths_cirr = number.of.liver.related.deaths/number.of.cirrhotic.people,
                                               perc_red_deaths = (lag(number.of.liver.related.deaths) - number.of.liver.related.deaths)/lag(number.of.liver.related.deaths)
)

final_clinical <- clinical_calcs %>% select(Strategy = strategy_name,
                                            `# HCV Infections` = number.of.total.HCV.infections,
                                            `# HCV Infections Identified` = number.of.total.HCV.identifications,
                                            `% Infections Identified Lifetime` = perc_ident_lifetime,
                                            `# Achieved SVR` = number.of.SVR.cases,
                                            `% Achieved SVR` = perc_svr,
                                            `Cirrhotic People` = number.of.cirrhotic.people,
                                            `% Reduction in Cirrhotic people` = perc_red_cirr,
                                            `Number of liver deaths` = number.of.liver.related.deaths,
                                            `% Liver deaths among cirrhotic people` = liver_deaths_cirr,
                                            `% Reduction in liver related deaths among cirrhotic people` = perc_red_deaths
)  

# Round and format non-NA values to currency

final_clinical <- final_clinical %>%
  mutate(
    `# HCV Infections` = ifelse(is.na(`# HCV Infections`), NA, format(round(`# HCV Infections`, 0), big.mark = ",")),
    `# HCV Infections Identified` = ifelse(is.na(`# HCV Infections Identified`), NA, format(round(`# HCV Infections Identified`, 0), big.mark = ",")),
    `% Infections Identified Lifetime` = ifelse(is.na(`% Infections Identified Lifetime`), NA, paste0(round(`% Infections Identified Lifetime` * 100, 2), "%")),
    `# Achieved SVR` = ifelse(is.na(`# Achieved SVR`), NA, format(round(`# Achieved SVR`, 0), big.mark = ",")),
    `% Achieved SVR` = ifelse(is.na(`% Achieved SVR`), NA, paste0(round(`% Achieved SVR` * 100, 2), "%")),
    `Cirrhotic People` = ifelse(is.na(`Cirrhotic People`), NA, format(round(`Cirrhotic People`, 0), big.mark = ",")),
    `% Reduction in Cirrhotic people` = ifelse(is.na(`% Reduction in Cirrhotic people`), NA, paste0(round(`% Reduction in Cirrhotic people` * 100, 2), "%")),
    `Number of liver deaths` = ifelse(is.na(`Number of liver deaths`), NA, format(round(`Number of liver deaths`, 0), big.mark = ",")),
    `% Liver deaths among cirrhotic people` = ifelse(is.na(`% Liver deaths among cirrhotic people`), NA, paste0(round(`% Liver deaths among cirrhotic people` * 100, 2), "%")),
    `% Reduction in liver related deaths among cirrhotic people` = ifelse(is.na(`% Reduction in liver related deaths among cirrhotic people`), NA, paste0(round(`% Reduction in liver related deaths among cirrhotic people` * 100, 2), "%"))
  )


#======================
# Write to a csv file
#======================

# Start a sink file with a CSV extension
sink('ICER_Sheet.csv')

# Write the first dataframe, with a title and final line separator 
cat('Table 1: ICER')
cat('\n')
write.csv(final_icer, row.names = FALSE)

# create empty rows in-between tables for spacing
cat('\n')

# Write the 2nd dataframe to the same sink
cat('Table 2: Clinical Outcomes')
cat('\n')
write.csv(final_clinical, row.names = FALSE)


# Close the sink
sink()
